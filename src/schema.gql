# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

type AuthTokensDto {
  accessToken: String!
  expiresIn: Float!
  refreshToken: String!
}

type CandleEntity {
  closeDate: IDate!
  closePrice: IPrice!
  createdAt: DateTime!
  id: ID!
  maxPrice: IPrice!
  minPrice: IPrice!
  openDate: IDate!
  openPrice: IPrice!
  poolAddress: String!
  transactions: [TransactionEntity!]!
  updatedAt: DateTime!
}

type ChannelEntity {
  createdAt: DateTime!
  id: ID!
  telegramId: String
  updatedAt: DateTime!
  verificationStatus: verificationStatusEnum!
}

type ConditionEntity {
  conditionsGroup: ConditionsGroupEntity!
  createdAt: DateTime!
  field: conditionFieldEnum!
  id: ID!
  operator: operatorEnum!
  refConditionsGroup: ConditionsGroupEntity
  refMilestone: MilestoneEntity
  updatedAt: DateTime!
  value: String!
}

type ConditionsGroupEntity {
  conditions: [ConditionEntity!]!
  createdAt: DateTime!
  description: String
  duration: Int!
  groupOperator: groupOperatorEnum!
  id: ID!
  milestone: MilestoneEntity!
  name: String
  refConditionsGroup: ConditionsGroupEntity
  refMilestone: MilestoneEntity
  updatedAt: DateTime!
}

input CreateCandleDto {
  poolAddress: String!
}

input CreateChannelDto {
  telegramId: String!
}

input CreateConditionDto {
  id: ID!
}

input CreateMilestoneDto {
  id: ID!
}

input CreatePoolDto {
  address: String!
}

input CreateSignalDto {
  tokenName: String!
}

input CreateStrategyDto {
  name: String!
}

input CreateTokenDto {
  name: String!
}

input CreateTradingDto {
  price: Float!
}

input CreateTradingTokenDto {
  id: String!
}

input CreateTransactionDto {
  poolAddress: String!
}

input CreateUserInput {
  tel: String!
  verificationCode: String!
}

input CreateWalletDto {
  address: String!
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

input EmailAuthDto {
  email: String!
  password: String!
}

"""DateTime custom scalar for Dayjs with DateService"""
scalar IDate

"""Custom scalar for prices using Big.js"""
scalar IPrice

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON

type MilestoneEntity {
  conditionsGroups: [ConditionsGroupEntity!]!
  createdAt: DateTime!
  description: String
  groupOperator: groupOperatorEnum!
  id: ID!
  name: String
  position: Int!
  refMilestone: MilestoneEntity
  strategy: StrategyEntity!
  type: milestoneTypeEnum!
  updatedAt: DateTime!
  value: String
}

type Mutation {
  createCandle(candle: CreateCandleDto!): CandleEntity!
  createChannel(channel: CreateChannelDto!): ChannelEntity!
  createCondition(condition: CreateConditionDto!): ConditionEntity!
  createConditionsGroup(conditionsGroup: CreateConditionDto!): ConditionsGroupEntity!
  createMilestone(milestone: CreateMilestoneDto!): MilestoneEntity!
  createPool(pool: CreatePoolDto!): PoolEntity!
  createSignal(signal: CreateSignalDto!): SignalEntity!
  createStrategy(strategy: CreateStrategyDto!): StrategyEntity!
  createToken(token: CreateTokenDto!): TokenEntity!
  createTrading(trading: CreateTradingDto!): TradingEntity!
  createTradingToken(tradingToken: CreateTradingTokenDto!): TradingTokenEntity!
  createTransaction(transaction: CreateTransactionDto!): TransactionEntity!
  createUser(user: CreateUserInput!): UserEntity!
  createWallet(wallet: CreateWalletDto!): WalletEntity!
  deleteCandle(id: String!): Void!
  deleteChannel(id: String!): Void!
  deleteCondition(id: String!): Void!
  deleteConditionsGroup(id: String!): Void!
  deleteMilestone(id: String!): Void!
  deletePool(id: String!): Void!
  deleteSignal(id: String!): Void!
  deleteStrategy(id: String!): Void!
  deleteToken(id: String!): Void!
  deleteTrading(id: String!): Void!
  deleteTradingToken(id: String!): Void!
  deleteTransaction(id: String!): Void!
  deleteUser(id: String!): Void!
  deleteWallet(id: String!): Void!
  me: AuthTokensDto!
  refreshTokens(refreshToken: String!): AuthTokensDto!
  signIn(emailAuth: EmailAuthDto!): AuthTokensDto!
  signInTelegram(telegramId: String!): AuthTokensDto!
  signUp(emailAuth: EmailAuthDto!): AuthTokensDto!
  signUpTelegram(telegramUser: TelegramUserDto!): AuthTokensDto!
  updateCandle(candle: UpdateCandleDto!): CandleEntity!
  updateChannel(channel: UpdateChannelDto!): ChannelEntity!
  updateCondition(condition: UpdateConditionDto!): ConditionEntity!
  updateConditionsGroup(conditionsGroup: UpdateConditionDto!): ConditionsGroupEntity!
  updateMilestone(milestone: UpdateMilestoneDto!): MilestoneEntity!
  updatePool(pool: UpdatePoolDto!): PoolEntity!
  updateSignal(signal: UpdateSignalDto!): SignalEntity!
  updateStrategy(strategy: UpdateStrategyDto!): StrategyEntity!
  updateToken(token: UpdateTokenDto!): TokenEntity!
  updateTrading(trading: UpdateTradingDto!): TradingEntity!
  updateTradingToken(tradingToken: UpdateTradingTokenDto!): TradingTokenEntity!
  updateTransaction(transaction: UpdateTransactionDto!): TransactionEntity!
  updateUser(user: UpdateUserInput!): UserEntity!
  updateWallet(wallet: UpdateWalletDto!): WalletEntity!
  verifyCode(verificationCode: String!): AuthTokensDto!
}

type PaginatedCandles {
  data: [CandleEntity!]!
  page: Int!
  totalCount: Int!
}

type PaginatedChannels {
  data: [ChannelEntity!]!
  page: Int!
  totalCount: Int!
}

type PaginatedConditions {
  data: [ConditionEntity!]!
  page: Int!
  totalCount: Int!
}

type PaginatedConditionsGroups {
  data: [ConditionsGroupEntity!]!
  page: Int!
  totalCount: Int!
}

type PaginatedMilestones {
  data: [MilestoneEntity!]!
  page: Int!
  totalCount: Int!
}

type PaginatedPools {
  data: [PoolEntity!]!
  page: Int!
  totalCount: Int!
}

type PaginatedSignals {
  data: [SignalEntity!]!
  page: Int!
  totalCount: Int!
}

type PaginatedStrategies {
  data: [StrategyEntity!]!
  page: Int!
  totalCount: Int!
}

type PaginatedTokens {
  data: [TokenEntity!]!
  page: Int!
  totalCount: Int!
}

type PaginatedTradingTokens {
  data: [TradingTokenEntity!]!
  page: Int!
  totalCount: Int!
}

type PaginatedTradings {
  data: [TradingEntity!]!
  page: Int!
  totalCount: Int!
}

type PaginatedTransactions {
  data: [TransactionEntity!]!
  page: Int!
  totalCount: Int!
}

type PaginatedUsers {
  data: [UserEntity!]!
  page: Int!
  totalCount: Int!
}

type PaginatedWallets {
  data: [WalletEntity!]!
  page: Int!
  totalCount: Int!
}

type PoolEntity {
  address: String!
  authority: String!
  baseDecimals: Float!
  baseMint: String!
  baseVault: String!
  createdAt: DateTime!
  id: ID!
  lookupTableAccount: String!
  lpDecimals: Float!
  lpMint: String!
  lpVault: String!
  marketAsks: String!
  marketAuthority: String!
  marketBaseVault: String!
  marketBids: String!
  marketEventQueue: String!
  marketId: String!
  marketProgramId: String!
  marketQuoteVault: String!
  marketVersion: Float!
  openOrders: String!
  programId: String!
  quoteDecimals: Float!
  quoteMint: String!
  quoteVault: String!
  targetOrders: String!
  tradingToken: TradingTokenEntity
  updatedAt: DateTime!
  version: Float!
  withdrawQueue: String!
}

type Query {
  candle(id: ID!): CandleEntity!
  candles(poolAddress: String, skip: Int, take: Int): PaginatedCandles!
  channel(id: ID!): ChannelEntity!
  channels(skip: Int, take: Int): PaginatedChannels!
  condition(id: ID!): ConditionEntity!
  conditions(skip: Int, take: Int): PaginatedConditions!
  conditionsGroup(id: ID!): ConditionsGroupEntity!
  conditionsGroups(skip: Int, take: Int): PaginatedConditionsGroups!
  getConditionField: [conditionFieldEnum!]!
  getErrors: [errorsEnum!]!
  getGroupOperators: [groupOperatorEnum!]!
  getMilestoneTypes: [milestoneTypeEnum!]!
  getOperators: [operatorEnum!]!
  milestone(id: ID!): MilestoneEntity!
  milestones(skip: Int, take: Int): PaginatedMilestones!
  pool(id: ID!): PoolEntity!
  pools(skip: Int, take: Int): PaginatedPools!
  signal(id: ID!): SignalEntity!
  signals(skip: Int, take: Int): PaginatedSignals!
  strategies(skip: Int, take: Int): PaginatedStrategies!
  strategy(id: ID!): StrategyEntity!
  token(id: ID!): TokenEntity!
  tokens(signalId: String, skip: Int, take: Int): PaginatedTokens!
  trading(id: ID!): TradingEntity!
  tradingToken(id: ID!): TradingTokenEntity!
  tradingTokens(skip: Int, take: Int, tradingId: String): PaginatedTradingTokens!
  tradings(skip: Int, take: Int): PaginatedTradings!
  transaction(id: ID!): TransactionEntity!
  transactions(candleId: String, poolAddress: String, skip: Int, take: Int): PaginatedTransactions!
  user(id: ID!): UserEntity!
  users(skip: Int, take: Int): PaginatedUsers!
  wallet(id: ID!): WalletEntity!
  wallets(skip: Int, take: Int): PaginatedWallets!
}

type SignalEntity {
  createdAt: DateTime!
  id: ID!
  poolAddress: String
  signaledAt: IDate!
  source: String!
  token: TokenEntity
  tokenAddress: String
  tokenName: String
  updatedAt: DateTime!
}

type StrategyEntity {
  createdAt: DateTime!
  description: String
  id: ID!
  milestones: [MilestoneEntity!]!
  name: String!
  tradings: [TradingEntity!]!
  updatedAt: DateTime!
}

input TelegramUserDto {
  added_to_attachment_menu: Boolean
  first_name: String!
  id: Float!
  is_bot: Boolean!
  is_premium: Boolean
  language_code: String
  last_name: String
  phone: String!
  username: String
}

type TokenEntity {
  address: String!
  chain: String!
  createdAt: DateTime!
  id: ID!
  name: String
  signal: SignalEntity
  signals: [SignalEntity!]!
  symbol: String
  tradingTokens: [TradingTokenEntity!]!
  updatedAt: DateTime!
}

type TradingEntity {
  createdAt: DateTime!
  disabled: Boolean!
  id: ID!
  microLamports: Float!
  price: Float
  sourceWallet: WalletEntity!
  strategy: StrategyEntity!
  targetWallet: WalletEntity!
  tokenTradingDuration: Float!
  tradingTokens: [TradingTokenEntity!]
  units: Float!
  updatedAt: DateTime!
}

type TradingTokenEntity {
  active: Boolean!
  amount: Float!
  checkedStrategy: JSON!
  createdAt: DateTime!
  id: ID!
  pool: PoolEntity!
  signaledAt: IDate!
  token: TokenEntity!
  trading: TradingEntity!
  updatedAt: DateTime!
}

type TransactionEntity {
  author: String
  candle: CandleEntity
  createdAt: DateTime!
  date: IDate!
  id: ID!
  poolAddress: String!
  price: IPrice!
  signature: String
  updatedAt: DateTime!
}

input UpdateCandleDto {
  id: ID!
}

input UpdateChannelDto {
  id: ID!
}

input UpdateConditionDto {
  id: ID!
}

input UpdateMilestoneDto {
  id: ID!
}

input UpdatePoolDto {
  id: ID!
}

input UpdateSignalDto {
  id: ID!
}

input UpdateStrategyDto {
  id: ID!
}

input UpdateTokenDto {
  id: ID!
}

input UpdateTradingDto {
  id: ID!
}

input UpdateTradingTokenDto {
  id: ID!
}

input UpdateTransactionDto {
  id: ID!
}

input UpdateUserInput {
  id: ID!
  tel: String!
  verificationCode: String!
}

input UpdateWalletDto {
  id: ID!
}

type UserEntity {
  createdAt: DateTime!
  email: String
  id: ID!
  password: String
  tel: String
  telegramId: String
  updatedAt: DateTime!
  verificationCode: String
  verificationStatus: verificationStatusEnum!
}

"""Represents NULL values"""
scalar Void

type WalletEntity {
  address: String!
  createdAt: DateTime!
  id: ID!
  name: String!
  sourceTradings: [TradingEntity!]!
  targetTradings: [TradingEntity!]!
  updatedAt: DateTime!
}

enum conditionFieldEnum {
  AUTHOR
  DATE
  PRICE
}

enum errorsEnum {
  AuthorizationHeaderIsMissing
  Forbidden
  InternalServerError
  InvalidEncryption
  InvalidEncryptionLength
  InvalidEnum
  InvalidPassword
  InvalidToken
  InvalidVerificationCode
  IsArray
  IsDate
  IsEmail
  IsNotEmpty
  IsNumber
  IsObject
  IsString
  Max
  MaxLength
  Min
  MinLength
  NotFound
  TokenIsMissing
  UserAlreadyExist
  UserNotExist
  UserNotFound
  UserNotVerified
}

enum groupOperatorEnum {
  AND
  OR
}

enum milestoneTypeEnum {
  BUY
  SELL
  SIGNAL
}

enum operatorEnum {
  EQUAL
  LESS
  LESS_EQUAL
  MORE
  MORE_EQUAL
}

enum verificationStatusEnum {
  NOT_VERIFIED
  VERIFIED
}